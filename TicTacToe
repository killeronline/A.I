using System;
using System.Collections.Generic;

namespace ConsoleApplication5
{
    #region Constants
    class Players
    {
        public static int Empty = 0;
        public static int WhitePlayer = 1;
        public static int BlackPlayer = 2;
    }

    class Pieces
    {
        public static int Empty = 0;
        public static int White = 1;
        public static int Black = 2;        
    }        
    #endregion

    public class Program
    {                
        public struct Cell
        {            
            public int piece;            
        };
        public struct Move
        {
            public int p ;
            public int r ;
            public int c ;            
            public int v ;
        };
        public struct Climax
        {
            public int counters ;
            public int fails ;
            public int handlers;
        };
		public static Cell[,] grid ;
        public static Move Best_Move;
        public static Move Hand_Move;
        public static Move Fail_Move;
        public static int Sentinel = 999;
        public static int PID ;
        public static int H;
        public static int Depth = 3;        
		
		static void Main(string[] args)
        {
            # region inputs
            grid = new Cell[3,3];
			for ( int i = 0 ; i < 3 ; i++ )
			{
				string[] line = Console.ReadLine().Trim().Split();
				for ( int j = 0 ; j < line.Length ; j++ )
				{						
														
					if ( line[j] == "0" )
					{
                        grid[i, j].piece = Pieces.Empty;
					}
                    else if ( line[j] == "1" )
                    {
                        grid[i, j].piece = Pieces.White;
                    }
                    else if (line[j] == "2")
                    {
                        grid[i, j].piece = Pieces.Black;
                    }
                    else
                    {
                        Console.WriteLine("Invalid Input");
                        return;
                    }
			    }
            }
            string pline = Console.ReadLine().Trim();
            if (pline == "1")
            {
                PID = Players.WhitePlayer;
            }
            else if (pline == "2")
            {
                PID = Players.BlackPlayer;
            }
            else
            {
                Console.WriteLine("Invalid Input");
                return;
            }
            #endregion
            
            /*  
             *  Current Heuristic Score
             *  
             *  Valid Moves
             *  {
             *      Execute Move
             *      New Heuristic Score
             *      UnExecute Move             
             *      Calculate Delta 
             *  }
             *  
             *  Valid Moves : Sorted By Delta
             *  {
             *      Execute and Remember Move
             *      Inverted Inputs for child Dimension
             *      -> BlackHole -> ()note -> delta and step as call back...
             *      Re-Invert the Inputs to parent Dimension
             *  }
             *  
             *  After The BlackHole Loop we must get a highest tilda ( when our move ) and Lowest tilda ( when opponent move ) and a step from thinking
             *  
             */
            g(0);
            Move choice = Best_Move.p == PID ? Best_Move : Hand_Move.p == PID ? Hand_Move : Fail_Move;            
            Console.WriteLine("{0} {1}",choice.c, choice.r);            
            Console.ReadLine();
		}

        public static Climax g(int LeveL)
        {
            Climax cx = new Climax();
            cx.counters = 0;
            cx.handlers = 0;
            cx.fails = 0;

            int _pid = LeveL % 2 == 0 ? PID : (PID == 1 ? 2 : 1);                  

            List<Move> Valid_Moves = new List<Move>();

            for (int i = 0; i < 3; i++)
            {
                for (int j = 0; j < 3; j++)
                {
                    if (grid[i, j].piece == 0)// Valid Move
                    {
                        Move m = new Move();
                        m.p = _pid;
                        m.r = i;
                        m.c = j;   
                     
                        Execute(m);                        

                        m.v = h(_pid);                        

                        UnExecute(m);

                        Valid_Moves.Add(m);
                    }
                }
            }
            
            Valid_Moves.Sort((x, y) => (x.v > y.v ? -1 : x.v < y.v ? 1 : 0));            

            if (Valid_Moves.Count > 0)
            {                
                
                foreach (Move m in Valid_Moves)
                {
                    if (m.v == Sentinel)
                    {
                        if (LeveL == 0)
                        {
                            Best_Move = m ;// Recording Immediate Best Move
                        }
                        cx.counters = Valid_Moves.Count ;// This move overrates all other moves
                        break;
                    }

                    if (LeveL < 2 * Depth)
                    {
                        Execute(m);

                        Climax tilda = g(LeveL + 1);

                        UnExecute(m);
                        
                        if (tilda.counters > 0)// Opp Sure Play
                        {
                            cx.fails++;
                        }
                        else if (tilda.handlers > 0)// Opp Sure Handles
                        {
                            cx.handlers++;
                        }
                        else if (tilda.fails > 0)// Forced Opp Fail
                        {
                            cx.counters++;
                        }
                        else
                        {
                            // tilda is interesting or No Move or Leaf Node
                        }                                                
                    }
                    else
                    {                        
                        if (m.v > 0)
                        {
                            cx.counters++;
                        }
                        else if (m.v == 0)
                        {
                            cx.handlers++;
                        }
                        else
                        {
                            cx.fails++;
                        }
                    }
                    if (LeveL == 0)
                    {
                        if (cx.counters > 0)
                        {
                            Best_Move = m;
                            break;
                        }
                        else if (cx.handlers > 0)
                        {
                            Hand_Move = m;
                            cx.handlers = 0;
                        }
                        else if (cx.fails > 0)
                        {
                            Fail_Move = m;
                            cx.fails = 0;
                        }
                        else
                        {
                            Fail_Move = m;
                            cx.fails = 0;
                        }
                    }                                                  
                }
            }
            // Else No Move Scenario             
            return cx ;
        }

        public static int h(int pid)
        {
            int s = 0 ; 

            for (int i = 0; i < 3; i++)// Any Row
            {
                int r = p(i, 0, pid) + p(i, 1, pid) + p(i, 2, pid);
                if ( r == 3)
                {
                    return Sentinel;
                }
                else if ( r > 0 )
                {
                    s++;
                }                
            }

            for (int i = 0; i < 3; i++)// Any Column
            {
                int c = p(0, i, pid) + p(1, i, pid) + p(2, i, pid);
                if (c == 3)
                {
                    return Sentinel;
                }
                else if ( c > 0 )
                {
                    s++;
                }
            }

            int fd = p(0, 0, pid) + p(1, 1, pid) + p(2, 2, pid);
            if ( fd == 3)// Backward Diagonal
            {
                return Sentinel;
            }
            else if ( fd > 0 )
            {
                s++;
            }

            int bd = p(0, 2, pid) + p(1, 1, pid) + p(2, 0, pid);
            if (bd == 3)// Forward Diagonal
            {
                return Sentinel;
            }
            else if( bd > 0 )
            {
                s++;
            }

            return s;
        }

        public static int p( int i , int j , int w )
        {
            return grid[i, j].piece == w ? 1 : grid[i, j].piece == 0 ? 0 : -9;
        }

        public static void Execute(Move m)
        {
            grid[m.r, m.c].piece = m.p;
        }

        public static void UnExecute(Move m)
        {
            grid[m.r, m.c].piece = 0;
        }

    }
}
