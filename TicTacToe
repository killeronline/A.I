using System;
using System.Text;
using System.Collections.Generic;

namespace ConsoleApplication5
{
    #region Constants
    class Players
    {
        public static int Empty = 0;
        public static int WhitePlayer = 1;
        public static int BlackPlayer = 2;
    }

    class Pieces
    {
        public static int Empty = 0;
        public static int White = 1;
        public static int Black = 2;        
    }        
    #endregion

    public class Program
    {                
        public struct Cell
        {            
            public int piece;            
        };
        public struct Move
        {
            public int p ;
            public int r ;
            public int c ;            
            public int v ;
        };        
		public static Cell[,] grid ;
        public static Move Best_Move;
        public static Move Hand_Move;
        public static Move Fail_Move;
        public static int Sentinel = 999;
        public static int PID ;        
        public static int Depth = 3;
        public static List<string> vdata = new List<string>();
        public static bool debug = false;
		
		static void Main(string[] args)
        {                                    
            //TakeInputs();
            int T = 0 ;
            grid = new Cell[3, 3];            
            Print_Board();
            while (T < 20)
            {
                vdata.Clear();                
                PID = 1;
                Best_Move.p = 0;
                Hand_Move.p = 0;
                Fail_Move.p = 0;
                g(0);
                Move choice = Best_Move.p == PID ? Best_Move : Hand_Move.p == PID ? Hand_Move : Fail_Move;
                //Print_Conclusion_Move(choice);
                Print_Board_And_Make_Move(choice);
                if (debug)
                {
                    System.IO.File.WriteAllLines(@"C:\Users\Administrator\Desktop\TTTAI\WriteLines.xml",vdata.ToArray());
                }
                //Console.ReadLine();
                string[] inp = Console.ReadLine().Trim().Split();
                if (inp.Length < 2)
                {
                    break;
                }
                grid[Int32.Parse(inp[0]), Int32.Parse(inp[1])].piece = 2;// MySelf
            }
		}

        public static void TakeInputs()
        {            
            grid = new Cell[3, 3];
            for (int i = 0; i < 3; i++)
            {
                string[] line = Console.ReadLine().Trim().Split();
                for (int j = 0; j < line.Length; j++)
                {

                    if (line[j] == "0")
                    {
                        grid[i, j].piece = Pieces.Empty;
                    }
                    else if (line[j] == "1")
                    {
                        grid[i, j].piece = Pieces.White;
                    }
                    else if (line[j] == "2")
                    {
                        grid[i, j].piece = Pieces.Black;
                    }
                    else
                    {
                        Console.WriteLine("Invalid Input");
                        return;
                    }
                }
            }
            string pline = Console.ReadLine().Trim();
            if (pline == "1")
            {
                PID = Players.WhitePlayer;
            }
            else if (pline == "2")
            {
                PID = Players.BlackPlayer;
            }
            else
            {
                Console.WriteLine("Invalid Input");
                return;
            }            
        }

        public static void Print_Board_And_Make_Move( Move _choice )
        {
            Console.WriteLine("Computer Move:{0} {1}",_choice.r ,_choice.c);
            grid[ _choice.r , _choice.c ].piece = _choice.p ;
            Print_Board();
        }

        public static void Print_Board()
        {
            Console.WriteLine();
            for (int i = 0; i < 3; i++)
            {
                Console.WriteLine("{0} {1} {2}", grid[i, 0].piece, grid[i, 1].piece, grid[i, 2].piece);
            }
            Console.WriteLine();
        }

        public static void Print_Conclusion_Move(Move _choice)
        {
            Console.WriteLine("{0} {1}", _choice.c, _choice.r);
        }

        public static void visualize( int lvl , int begin , int _mr)
        {
            StringBuilder s = new StringBuilder();
            int tabspaces = 8;
            for (int i = 0; i < lvl * tabspaces; i++)
            {
                s.Append(' ');
            }
            if (begin == 1)
            {                
                vdata.Add(String.Format("{0} LvL{1}", s, lvl));                                
                for (int i = 0; i < 3; i++)
                {
                    vdata.Add(String.Format("{0} {1} {2} {3}", s, grid[i, 0].piece, grid[i, 1].piece, grid[i, 2].piece));
                }
                vdata.Add(String.Format("{0} <N>", s));
            }
            else
            {
                vdata.Add(String.Format("{0} </N>", s));
                vdata.Add(String.Format("{0} MR:{1}", s,_mr));
            }
        }

        public static int g(int LeveL)
        {
            if (debug)
            {
                visualize(LeveL, 1, -1);
            }

            int _pid = LeveL % 2 == 0 ? PID : (PID == 1 ? 2 : 1);

            List<Move> Valid_Moves = Generate_Valid_Moves(_pid);
            
            Valid_Moves.Sort((x, y) => (x.v > y.v ? -1 : x.v < y.v ? 1 : 0));

            int master_return ;

            if (Valid_Moves.Count > 0)
            {
                if (LeveL % 2 == 0)
                {
                    master_return = Int32.MinValue;
                }
                else
                {
                    master_return = Int32.MaxValue;
                }
                foreach (Move m in Valid_Moves)
                {                    
                    if (m.v == Sentinel)
                    {
                        if (LeveL % 2 == 0)
                        {
                            master_return = m.v;
                        }
                        else
                        {
                            master_return = -Sentinel;
                        }
                        if (LeveL == 0)
                        {
                            Best_Move = m;
                        }                        
                        break; 
                    }

                    if (LeveL < 2 * Depth)
                    {
                        Execute(m);

                        int tilda = g(LeveL + 1);// Perception

                        UnExecute(m);

                        if (LeveL % 2 == 0)
                        {
                            if (tilda > master_return)
                            {
                                master_return = tilda;

                                if ( LeveL == 0)
                                {
                                    Best_Move = m;
                                }

                                if (tilda == Sentinel)
                                {
                                    break;
                                }
                            }
                        }
                        else
                        {
                            if (tilda < master_return)
                            {
                                master_return = tilda;
                            }
                        }
                    }
                    else // Leaf Nodes
                    {
                        if (m.v > master_return)
                        {
                            master_return = m.v;

                            if (Depth == 0)
                            {
                                Best_Move = m;
                            }
                        }
                    }                                                      
                }
            }
            else
            {
                master_return = 0;// No Move Scenario : End Nodes
            }
            if (debug)
            {
                visualize(LeveL, 0, master_return);
            }
            return master_return ;
        }

        public static int h(int pid)
        {
            int s = 0 ; 

            for (int i = 0; i < 3; i++)// Any Row
            {
                int r = p(i, 0, pid) + p(i, 1, pid) + p(i, 2, pid);
                if ( r == 3)
                {
                    return Sentinel;
                }
                else if ( r > 0 )
                {
                    s++;
                }                
            }

            for (int i = 0; i < 3; i++)// Any Column
            {
                int c = p(0, i, pid) + p(1, i, pid) + p(2, i, pid);
                if (c == 3)
                {
                    return Sentinel;
                }
                else if ( c > 0 )
                {
                    s++;
                }
            }

            int fd = p(0, 0, pid) + p(1, 1, pid) + p(2, 2, pid);
            if ( fd == 3)// Backward Diagonal
            {
                return Sentinel;
            }
            else if ( fd > 0 )
            {
                s++;
            }

            int bd = p(0, 2, pid) + p(1, 1, pid) + p(2, 0, pid);
            if (bd == 3)// Forward Diagonal
            {
                return Sentinel;
            }
            else if( bd > 0 )
            {
                s++;
            }

            return s;
        }

        public static int p( int i , int j , int w )
        {
            return grid[i, j].piece == w ? 1 : grid[i, j].piece == 0 ? 0 : -9;
        }

        public static List<Move> Generate_Valid_Moves( int pid )
        {
            List<Move> Possible_Moves = new List<Move>();

            for (int i = 0; i < 3; i++)
            {
                for (int j = 0; j < 3; j++)
                {
                    if (grid[i, j].piece == 0)// Valid Move
                    {
                        Move m = new Move();
                        m.p = pid;
                        m.r = i;
                        m.c = j;

                        Execute(m);

                        m.v = h(pid);

                        UnExecute(m);

                        Possible_Moves.Add(m);
                    }
                }
            }

            return Possible_Moves;
        }

        public static void Execute(Move m)
        {
            grid[m.r, m.c].piece = m.p;
        }

        public static void UnExecute(Move m)
        {
            grid[m.r, m.c].piece = 0;
        }

    }
}
